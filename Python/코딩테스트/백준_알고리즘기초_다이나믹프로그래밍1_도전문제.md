# 코딩테스트 준비 - Python



출처 : 백준 알고리즘 문제 [Baekjoon Online Judge](https://www.acmicpc.net/)



## 알고리즘 기초 1/2 - 다이나믹프로그래밍1(도전)



#### 402 -  문제번호 : 17404

 ##### 제목 : RGB거리 2

- 문제 : RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

  집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

  - 1번 집의 색은 2번, N번 집의 색과 같지 않아야 한다.
  - N번 집의 색은 N-1번, 1번 집의 색과 같지 않아야 한다.
  - i(2 ≤ i ≤ N-1)번 집의 색은 i-1, i+1번 집의 색과 같지 않아야 한다.

- 입력 : 첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

- 출력 : 첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

- 예제 입력1

  ```
  3
  26 40 83
  49 60 57
  13 89 993
  ```

- 예제 출력1

  ```
  110
  ```

- 제출 코드

```python
import sys
n = int(sys.stdin.readline())
colors = []
for i in range(n):
    colors.append(list(map(int,sys.stdin.readline().split())))
INF = 1000*1000
ans = INF
for i in range(3):
    dp = [[INF,INF,INF] for _ in range(n)]
    dp[0][i] = colors[0][i]
    for j in range(1,n):
    # 빨간색 선택할경우
        dp[j][0] = min(dp[j - 1][1], dp[j - 1][2]) + colors[j][0]
    # 초록색 선택할경우
        dp[j][1] = min(dp[j - 1][0], dp[j - 1][2]) + colors[j][1]
    # 파란색 선택할경우
        dp[j][2] = min(dp[j - 1][0], dp[j - 1][1]) + colors[j][2]
    for j in range(3):
        if i != j:
            ans = min(ans, dp[-1][j])
print(ans)
```



