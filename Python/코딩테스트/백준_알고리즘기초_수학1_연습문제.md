# 코딩테스트 준비 - Python



출처 : 백준 알고리즘 문제 [Baekjoon Online Judge](https://www.acmicpc.net/)



## 알고리즘 기초 1/2 - 수학1



#### 301 -  문제번호 : 9613

 ##### 제목 : GCD 합

- 문제 :  양의 정수 n개가 주어졌을 때, 가능한 모든 쌍의 GCD의 합을 구하는 프로그램을 작성하시오.

- 입력 : 첫째 줄에 테스트 케이스의 개수 t (1 ≤ t ≤ 100)이 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 각 테스트 케이스는 수의 개수 n (1 < n ≤ 100)가 주어지고, 다음에는 n개의 수가 주어진다. 입력으로 주어지는 수는 1,000,000을 넘지 않는다.

- 출력 : 각 테스트 케이스마다 가능한 모든 쌍의 GCD의 합을 출력한다.

- 예제 입력1

  ```
  3
  4 10 20 30 40
  3 7 5 12
  3 125 15 25
  ```

- 예제 출력1

  ```
  70
  3
  35
  ```

- 제출 코드

```python
import sys
T = int(sys.stdin.readline())

def gcd(a,b): # 최대공약수 구하는 함수.
    while b > 0:
        a, b = b, a % b
    return a

for _ in range(T):
    nums = list(map(int,sys.stdin.readline().split()))
    n = nums.pop(0)
    nums.sort()
    
    sum = 0
    for i in range(len(nums)-1):
        for j in range(i+1, len(nums)):
            sum += gcd(nums[i], nums[j])
    print(sum)
```



#### 301 -  문제번호 : 17087

 ##### 제목 : 숨바꼭질 6

- 문제 :  수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, ..., AN에 있다.

  수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.

  모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.

- 입력 : 첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.

- 출력 : 가능한 D값의 최댓값을 출력한다.

- 예제 입력1

  ```
  3 3
  1 7 11
  ```

- 예제 출력1

  ```
  2
  ```

- 제출 코드

```python
import sys
n, s= map(int,sys.stdin.readline().split())
a = list(map(int, sys.stdin.readline().split()))
d =[]

def gcd(a,b):
    if b == 0:
        return a
    else:
        return gcd(b, a%b)
answer = abs(s-a[0])

if s == 1:
    print(answer)
else:
    for i in range(1,n):
        answer = gcd(answer,abs(s-a[i]))
    print(answer)
```



#### 301 -  문제번호 : 1373

 ##### 제목 : 2진수 8진수

- 문제 :  2진수가 주어졌을 때, 8진수로 변환하는 프로그램을 작성하시오.

- 입력 : 첫째 줄에 2진수가 주어진다. 주어지는 수의 길이는 1,000,000을 넘지 않는다.

- 출력 : 첫째 줄에 주어진 수를 8진수로 변환하여 출력한다.

- 예제 입력1

  ```
  11001100
  ```

- 예제 출력1

  ```
  314
  ```

- 제출 코드

```python
print(oct(int(input(),2))[2:]) 
```

8진법으로 바꿔주는 내장함수 존재! 

8진법을 나타낼때 0o가 붙어서 출려되므로 [2:]부터 출력! 



#### 301 -  문제번호 : 1212

 ##### 제목 : 8진수 2진수

- 문제 : 8진수가 주어졌을 때, 2진수로 변환하는 프로그램을 작성하시오.

- 입력 : 첫째 줄에 8진수가 주어진다. 주어지는 수의 길이는 333,334을 넘지 않는다.

- 출력 : 첫째 줄에 주어진 수를 2진수로 변환하여 출력한다. 수가 0인 경우를 제외하고는 반드시 1로 시작해야 한다.

- 예제 입력1

  ```
  314
  ```

- 예제 출력1

  ```
  11001100
  ```

- 제출 코드

```python
print(bin(int(input(),8))[2:])
```

2진법으로 바꿔주는 내장함수 존재! 

8진법을 나타낼때 0b가 붙어서 출려되므로 [2:]부터 출력! 



#### 301 -  문제번호 : 2089

 ##### 제목 : -2진수

- 문제 : -2진법은 부호 없는 2진수로 표현이 된다. 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다. 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.

  10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.

- 입력 : 첫 줄에 10진법으로 표현된 수 N이 주어진다.

- 출력 : -2진법 수를 출력한다.

- 제한 : -2,000,000,000 ≤ N ≤ 2,000,000,000

- 예제 입력1

  ```
  -13
  ```

- 예제 출력1

  ```
  110111
  ```

- 제출 코드

```python
import sys
N = int(sys.stdin.readline())

if N == 0:
    print(0)
answer=''
while N != 0:
    if N % (-2):
        answer = '1' + answer
        N = N//-2 +1
    else:
        answer = '0' + answer
        N=N//-2
print(answer)

```



#### 301 -  문제번호 : 17103

 ##### 제목 : 골드바흐 파티션

- 문제 : 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다. 짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.

- 입력 : 첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.

- 출력 : 각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.

- 제한 : -2,000,000,000 ≤ N ≤ 2,000,000,000

- 예제 입력1

  ```
  5
  6
  8
  10
  12
  100
  ```

- 예제 출력1

  ```
  1
  1
  2
  1
  6
  ```

- 제출 코드

```python

```

