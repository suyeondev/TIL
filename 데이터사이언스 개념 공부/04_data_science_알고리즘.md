# 알고리즘



## 알고리즘이란?

어떤 문제를 해결하기 위한 절차, 방법, 명령어들의 집합



카드를 오름차순(1부터 13까지)으로 정렬한다고 가정할 때,

- 보고 정렬 (bogo sort) - 카드를 랜덤하게 섞다가 우연히 오름차순으로 정렬될 때까지 반복
- 버블 정렬 (bubble sort) - 차례로 2장의 카드를 뽑아서 내림차순으로 되어있으면 오름차순으로 정렬한 뒤에 되돌리고, 그렇지 않으면 원래 위치로 되돌리는 절차를 반복
- 삽입 정렬 (insertion sort) - 카드를 한장씩 테이블에 놓고, 카드 순서가 반드시 오름차순이 되도록 새로 배치해가는 방법
- 병합 정렬 (merge sort) - 13장의 카드를 2장씩 7개 그룹으로 나누고 각 그룹을 오름차순으로 정렬하고 다시 두그룹씩 골라서 그 4장의 카드가 오름차순이 되도록 결합하는 방법
- 퀵 정렬 (quick sort) - 카드를 적당히 한줄로 나열하고 어떤 수를 기준으로 그보다 큰 카드가 오른쪽, 작은 카드가 왼쪽에 오도록 바꾸는 동작을 반복하는 방법



## 시간복잡도

일반적으로 알고리즘은 가장 빠르고 최대한 메모리 영역을 낭비하지 않는 방법을 선택해야 한다.

- 시간복잡도 : 처리에 걸리는 시간

- 공간복잡도 : 필요한 메모리 영역

 

좋은 알고리즘이란 빠로고, 공간을 덜 쓰는 것으로 최선, 평균, 최악 시간(공간)복잡도를 고려해서 평가한다.



복잡도를 평가할 때는 일반적으로 **빅오 표기법**을 이용한다. 



빅오 표기법의 핵심은 복잡도를 **근사적으로 평가하는 것.**



**1. 상수항 무시 :** 빅오 표기법은 데이터 입력값(n)이 충분히 크다고 가정하고 있어서 알고리즘의 효율성 또한 데이터 입력값(n)의 크기에 따라 영향 받기 때문에 상수항 같은 사소한 부분은 무시한다.
$$
O(3n) --> O(n)
$$
**2. 영향력 없는 항 무시 :** 빅오 표기법은 데이터 입력값(n)의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다.
$$
O(n^2 + 3n + 1) --> O(n^2)
$$
계산량 증가 속도는 전혀 다르다 



![post-thumbnail](https://media.vlpt.us/images/welloff_jj/post/5d29a3fb-c5e1-4f81-919b-7ddfd774add5/%E1%84%87%E1%85%B5%E1%86%A8%E1%84%8B%E1%85%A9.jpeg)

이미지 출처 : https://velog.io/@welloff_jj/Complexity-and-Big-O-n

  

### 삽입정렬의 시간복잡도

카드를 오름차순으로 정렬한다고 할 때, (5장일경우)

0 1 2 3 4 번의 자리가 있다고 칠때,

처음 카드는 0번에 배치되고, 다음 카드는 0번 카드와 비교해서 그보다 크면 1번에 배치하고, 그렇지 않으면 0번 카드를 하나 오른쪽으로 이동하고 배치하는 것을 반복.(한장씩 크기를 비교해 정렬해 간다.)

```python
S = {1, 4, 6, 3, 2} # 적당히 나열된 카드

def insertionsort(S):                                                  
    for i in range(1, len(S)): # 0번째 카드는 이미 배치완료	
        card = S[i] # i 번째 카드를 새로 배치하려고 한다
        j = i -1 # 이미 배치된 카드는 0부터 i-1번째
        while(j>-1 and S[j]>card): # 오른쪽부터 판정. j번째 카드가 배치할 카드보다 작아지면 루프를 빠져나간다
            S[j+i] = S[j] # 배치할 카드보다 큰 카드를 오른쪽으로 옮긴다
            j -= 1 # 판정위치를 하나 왼쪽으로 옮긴다
        S[j+1] = card # 새로 카드를 배치한다
    return S
print(insertionsort(S))
```

for 문과 while문의 곱이므로 O(n^2)의 시간복잡도를 가진다.



### 병합 정렬의 시간복잡도

카드를 2장씩 묶어, 각각의 그룹을 오름차순으로 나열하고, 이번에는 두 그룹씩 선택해서 4장의 카드가 오름차순이 되도록 결합(merge)하는 동작을 반복하며 정렬하는 방법.

병합 정렬의 경우, 전체 문제의 시간복잡도는 부분 문제를 푸는 시간과 각 결과를 통합해가는 시간의 합이 된다고 생각할 수 있다.



```python
def mergesort(S):
    result = []
    if len(S)<2: # 리스트 길이가 1인 경우 정렬할 필요가 없다
        return S
    mid = int(len(S)/2) # 한가운데 위치를 구한다
    x = mergesort(S[:mid]) # 재귀적 호출 : 분할한 문제에 대해 병합 정렬을 한다
    y = mergesort(S[mid:]) # 재귀적 호출
    i,j = 0,0 
    
    while i < len(x) and j < len(y): # 정렬이 끝난 그룹을 결합해 간다
        if x[i]>y[i]:
            result.append(y[j])
            j += 1
        else:
            result.append(x[i])
            i += 1
    result += x[i:]
    result += y[j:]
    return result
    
```

병합 정렬은작은 문제로 분할하는  2분할과 루프의 곱으로 계산할 수 있고, 시간 복잡도는 O(nlogn)인 준선형이 된다.



[참고문헌] - 그림으로 배우는 데이터과학 Data Science - 히사노 료헤이, 키와키 타이치 지음 김성훈 옮김

 
